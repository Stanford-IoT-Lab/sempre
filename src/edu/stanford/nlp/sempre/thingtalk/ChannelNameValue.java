package edu.stanford.nlp.sempre.thingtalk;

import java.util.*;

import edu.stanford.nlp.sempre.Value;
import fig.basic.LispTree;

public class ChannelNameValue extends Value {
  public final String kind;
  public final String channelName;
  public final Map<String, Type> argtypes;
  public final Map<String, String> argcanonicals;

  public ChannelNameValue(LispTree tree) {
    this.kind = tree.child(1).value;
    this.channelName = tree.child(2).value;
    this.argtypes = new HashMap<>();
    this.argcanonicals = new HashMap<>();

    for (int i = 3; i < tree.children.size(); i++) {
      argtypes.put(tree.child(i).child(0).value, Type.fromString(tree.child(i).child(2).value));
      argcanonicals.put(tree.child(i).child(0).value, tree.child(i).child(1).value);
    }
  }

  public ChannelNameValue(String kind, String channelName, List<String> argnames, List<String> argcanonicals,
      List<Type> argtypes) {
    this.kind = kind;
    this.channelName = channelName;
    this.argtypes = new HashMap<>();
    this.argcanonicals = new HashMap<>();

    Iterator<String> nameit = argnames.iterator();
    Iterator<Type> typeit = argtypes.iterator();
    Iterator<String> canonicalit = argcanonicals.iterator();
    while (typeit.hasNext() && nameit.hasNext() && canonicalit.hasNext()) {
      String name = nameit.next();
      this.argtypes.put(name, typeit.next());
      this.argcanonicals.put(name, canonicalit.next());
    }
  }

  public Collection<String> getArgNames() {
    return argtypes.keySet();
  }

  public Type getArgType(String name) {
    return argtypes.get(name);
  }

  public String getArgCanonical(String name) {
    return argcanonicals.get(name);
  }

  @Override
  public LispTree toLispTree() {
    LispTree tree = LispTree.proto.newList();
    tree.addChild("channel");
    tree.addChild(kind);
    tree.addChild(channelName);
    for (Map.Entry<String, Type> e : argtypes.entrySet()) {
      LispTree child = LispTree.proto.newList();
      child.addChild(e.getKey());
      child.addChild(argcanonicals.get(e.getKey()));
      child.addChild(e.getValue().toString());
      tree.addChild(child);
    }
    return tree;
  }

  @Override
  public Map<String, Object> toJson() {
    Map<String, Object> json = new HashMap<>();
    // this funky representation is for compat with NameValue
    json.put("id", "tt:" + kind + "." + channelName);
    return json;
  }

  // Generated by Eclipse

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + argtypes.hashCode();
    result = prime * result + channelName.hashCode();
    result = prime * result + kind.hashCode();
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (getClass() != obj.getClass())
      return false;
    ChannelNameValue other = (ChannelNameValue) obj;
    if (!argtypes.equals(other.argtypes))
      return false;
    if (!channelName.equals(other.channelName))
      return false;
    if (!kind.equals(other.kind))
      return false;
    return true;
  }

}

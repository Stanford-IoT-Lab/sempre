# JavaExecutor Functions
(def @tempValueCast edu.stanford.nlp.sempre.thingtalk.ThingTalk.tempValueCast)

(def @paramForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.paramForm)

(def @trigParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.trigParam)
(def @queryParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.queryParam)
(def @actParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.actParam)

(def @cmdForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.cmdForm)

(def @ansForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.ansForm)

(def @jsonOut edu.stanford.nlp.sempre.thingtalk.ThingTalk.jsonOut)

(def @special edu.stanford.nlp.sempre.thingtalk.ThingTalk.special)

# Value Parsing
(rule $NumValue ($PHRASE) (NumberFn) (anchored 1))
(rule $ValueNoString ($PHRASE) (DateFn) (anchored 1))
(rule $ValueNoString ($PHRASE) (TimeFn) (anchored 1))
(rule $ValueNoString ($NumValue) (IdentityFn))
(rule $ValueNoString ($NumValue c) (lambda num (call @tempValueCast (string "C") (var num))))
(rule $ValueNoString ($NumValue f) (lambda num (call @tempValueCast (string "F") (var num))))
(rule $ValueNoString (@true) (ConstantFn (boolean true)))
(rule $ValueNoString (@false) (ConstantFn (boolean false)))
(rule $Value ($ValueNoString) (IdentityFn))
(rule $Value ($PHRASE) (IdentityFn) (anchored 1))

# FIXME: Integrate this to improve the canonicals
#(rule $PlaceValue ($PHRASE) (FilterNerSpanFn LOCATION) (anchored 1))
#(rule $PersonValue ($PHRASE) (FilterNerSpanFn PERSON) (anchored 1))
#(rule $OrgValue ($PHRASE) (FilterNerSpanFn ORGANIZATION) (anchored 1))

# Argument Names
(rule $ArgName ($PHRASE) (thingtalk.ThingpediaLexiconFn param))

# operators
# DO NOT replace this with SimpleLexiconFn or similar: FloatingParser
# must see all the rules to generate all the ops
# also make sure that at most $BeamSize branches belong to this
# category - that way FloatingParser will generate all of them
# and it will be equivalent to writing down all combinations in
# $Arg
(rule $Op (@is) (ConstantFn (string is)))
(rule $Op (@contains) (ConstantFn (string contains)))
(rule $Op (@has) (ConstantFn (string has)))
(rule $Op @is_greater_than (ConstantFn (string ">")))
(rule $Op @is_less_than (ConstantFn (string "<")))

# Arguments
(rule $Arg ($ArgName $Op $Value) (lambda arg (lambda op (lambda value (call @paramForm (var arg) (var op) (var value))))))
(rule $ValidArg ($Arg) (thingtalk.FilterInvalidArgFn))

# Action Handling
(rule $ActionName ($PHRASE) (thingtalk.ThingpediaLexiconFn action))

(rule $Action0 ($ActionName) (lambda act (call @actParam (var act))))
(rule $Action1 ($Action0 @with $ValidArg) (lambda act (lambda arg (call @actParam (var act) (var arg)))))
(rule $Action2 ($Action1 @with $ValidArg) (lambda act (lambda arg (call @actParam (var act) (var arg)))))
(rule $Action3 ($Action2 @with $ValidArg) (lambda act (lambda arg (call @actParam (var act) (var arg)))))

(rule $Action ($Action0) (thingtalk.FilterInvalidInvocationFn))
(rule $Action ($Action1) (thingtalk.FilterInvalidInvocationFn))
(rule $Action ($Action2) (thingtalk.FilterInvalidInvocationFn))
(rule $Action ($Action3) (thingtalk.FilterInvalidInvocationFn))
#(rule $Action ($Action0) (IdentityFn))
#(rule $Action ($Action1) (IdentityFn))
#(rule $Action ($Action2) (IdentityFn))
#(rule $Action ($Action3) (IdentityFn))

(rule $TriggerName ($PHRASE) (thingtalk.ThingpediaLexiconFn trigger))

(rule $Trigger0 ($TriggerName) (lambda trig (call @trigParam (var trig))))
(rule $Trigger1 ($Trigger0 @and $ValidArg) (lambda trig (lambda arg (call @trigParam (var trig) (var arg)))))
(rule $Trigger2 ($Trigger1 @and $ValidArg) (lambda trig (lambda arg (call @trigParam (var trig) (var arg)))))
(rule $Trigger3 ($Trigger2 @and $ValidArg) (lambda trig (lambda arg (call @trigParam (var trig) (var arg)))))

(rule $Trigger ($Trigger0) (thingtalk.FilterInvalidInvocationFn))
(rule $Trigger ($Trigger1) (thingtalk.FilterInvalidInvocationFn))
(rule $Trigger ($Trigger2) (thingtalk.FilterInvalidInvocationFn))
(rule $Trigger ($Trigger3) (thingtalk.FilterInvalidInvocationFn))
#(rule $Trigger ($Trigger0) (IdentityFn))
#(rule $Trigger ($Trigger1) (IdentityFn))
#(rule $Trigger ($Trigger2) (IdentityFn))
#(rule $Trigger ($Trigger3) (IdentityFn))

(rule $QueryName ($PHRASE) (thingtalk.ThingpediaLexiconFn query))

(rule $Query0 ($QueryName) (lambda query (call @queryParam (var query))))
(rule $Query1 ($Query0 @and $ValidArg) (lambda query (lambda arg (call @queryParam (var query) (var arg)))))
(rule $Query2 ($Query1 @and $ValidArg) (lambda query (lambda arg (call @queryParam (var query) (var arg)))))
(rule $Query3 ($Query2 @and $ValidArg) (lambda query (lambda arg (call @queryParam (var query) (var arg)))))

(rule $Query ($Query0) (thingtalk.FilterInvalidInvocationFn))
(rule $Query ($Query1) (thingtalk.FilterInvalidInvocationFn))
(rule $Query ($Query2) (thingtalk.FilterInvalidInvocationFn))
(rule $Query ($Query3) (thingtalk.FilterInvalidInvocationFn))
#(rule $Query ($Query0) (IdentityFn))
#(rule $Query ($Query1) (IdentityFn))
#(rule $Query ($Query2) (IdentityFn))
#(rule $Query ($Query3) (IdentityFn))

(rule $MonitorIf @monitor_if (ConstantFn (string "")))
(rule $Notify ($MonitorIf $Trigger) (SelectFn 1))

(rule $Device ($TOKEN) (thingtalk.ThingpediaLexiconFn kind))

(rule $Help (@help) (ConstantFn (string generic)) (anchored 1))
(rule $Help (@help $Device) (IdentityFn))

(rule $Discovery (@discover) (ConstantFn (string generic)))
(rule $Discovery (@discover $Device) (IdentityFn))

(rule $Configuration (@configure) (ConstantFn (string generic)))
(rule $Configuration (@configure $Device) (IdentityFn))

(rule $Listing (@devices) (ConstantFn (string device)))
(rule $Listing (@queries) (ConstantFn (string query)))
(rule $Listing (@commands) (ConstantFn (string command)))

(rule $Information (@list) (ConstantFn (string generic)))
(rule $Information (@list $Listing) (IdentityFn))

# Command handling
(rule $Command ($Help) (lambda value (call @cmdForm (string "help") (var value))))
(rule $Command ($Discovery) (lambda value (call @cmdForm (string "discover") (var value))))
(rule $Command ($Information) (lambda value (call @cmdForm (string "list") (var value))))
(rule $Command ($Configuration) (lambda value (call @cmdForm (string "configure") (var value))))

# special handling
# this used to be in SimpleLexicon but we moved it here for two reasons:
# 1) FloatingParser and SimpleLexicon do not like each other, meaning that you need
# to use the exact words in the lexicon for FloatingParser to parse properly (regardless of
# paraphrases)
# 2) It's easier to translate like this, and we don't need to teach SimpleLexicon
# about language tags
(rule $Special (@yes) (ConstantFn tt:root.special.yes))
(rule $Special (@no) (ConstantFn tt:root.special.no))
(rule $Special (@hello) (ConstantFn tt:root.special.hello))
(rule $Special (@thanks) (ConstantFn tt:root.special.thankyou))
(rule $Special (@sorry) (ConstantFn tt:root.special.sorry))
(rule $Special (@cool) (ConstantFn tt:root.special.cool))
(rule $Special @never_mind (ConstantFn tt:root.special.nevermind))
# this is a literal, it is not translated
(rule $Special (debug) (ConstantFn tt:root.special.debug))

# Answer handling
# NOTE 1: string answers are handled by putting Sabrina in "raw" mode
# which bypasses sempre
# DO NOT put $Answer -> $StringValue here, it would catch everything and confuse the parser
# NOTE 2: boolean answers are matched to yes/no, which are specials
# but you still need to handle them here to match synonyms of true/false like on/off
# that should not be learned as synonyms of yes/no
(rule $Answer ($ValueNoString) (lambda value (call @ansForm (string "Date") (var value))))

(rule $ROOT ($Command) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Action) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Notify) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Query) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Answer) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Special) (lambda spl (call @special (var spl))))

# JavaExecutor Functions
(def @measureValueCast edu.stanford.nlp.sempre.thingtalk.ThingTalk.measureValueCast)
(def @phoneNumberCast edu.stanford.nlp.sempre.thingtalk.ThingTalk.phoneNumberCast)
(def @emailAddressCast edu.stanford.nlp.sempre.thingtalk.ThingTalk.emailAddressCast)

(def @paramForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.paramForm)

(def @trigParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.trigParam)
(def @queryParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.queryParam)
(def @actParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.actParam)

(def @timeRule edu.stanford.nlp.sempre.thingtalk.ThingTalk.timeRule)
(def @timeSpanRule edu.stanford.nlp.sempre.thingtalk.ThingTalk.timeSpanRule)
(def @ifttt edu.stanford.nlp.sempre.thingtalk.ThingTalk.ifttt)

(def @cmdForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.cmdForm)

(def @ansForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.ansForm)

(def @jsonOut edu.stanford.nlp.sempre.thingtalk.ThingTalk.jsonOut)

(def @special edu.stanford.nlp.sempre.thingtalk.ThingTalk.special)

# Value Parsing
(rule $NumValue (@one) (ConstantFn (number 1)))
(rule $NumValue ($PHRASE) (NumberFn) (anchored 1))
(rule $DateValue ($PHRASE) (DateFn) (anchored 1))
(rule $TimeValue ($PHRASE) (TimeFn) (anchored 1))
(for @unit (s min h day week mon year)
	(rule $TimeIntervalValue ($NumValue @unit) (lambda num (call @measureValueCast (string @unit) (var num))))
)
(for @unit (C F byte KB MB GB TB)
	(rule $MeasureValue ($NumValue @unit) (lambda num (call @measureValueCast (string @unit) (var num))))
)
(rule $BooleanValue (@true) (ConstantFn (boolean true)))
(rule $BooleanValue (@false) (ConstantFn (boolean false)))
# one can choose to enable floating strings, which means full strings to be picked up
# by anchors, or just single tokens, also picked up by anchors
(when floatingstrings
	(rule $StrValue ($PHRASE) (IdentityFn) (anchored 1))
)
(when (not floatingstrings)
	(rule $StrValue ($TOKEN) (IdentityFn) (anchored 1))
)
(rule $StringValue (`` $StrValue '') (IdentityFn))
# we always have this anchored rule, so that we always pick up
# if the user explicitly types in quotes
(rule $StringValue (`` $PHRASE '') (IdentityFn) (anchored 1))
# work around someweirdness in the corenlp tokenizer
# this is always anchored because it deals with explicitly added quotes
(rule $StringValue ('' $PHRASE '') (IdentityFn) (anchored 1))
# handle usernames, slack channel names, hashtags, etc.
(rule $StringValue ($TOKEN) (FilterRegexFn "[@#](.+)") (anchored 1))
# same thing but with a space in between
# we need this because voice recognition converts "hashtag random" to "# random"
# instead of "#random"
(rule $StringValue ("#" $TOKEN) (IdentityFn) (anchored 1))
(rule $StringValue ("@" $TOKEN) (IdentityFn) (anchored 1))
(rule $LocationValue ($PHRASE) (thingtalk.LocationLexiconFn @language_tag) (anchored 1))
(rule $LocationValue (@here) (ConstantFn (location rel_current_location -1 -1) fb:type.any))
(rule $LocationValue @at_home (ConstantFn (location rel_home -1 -1) fb:type.any))
(rule $LocationValue @at_work (ConstantFn (location rel_work -1 -1) fb:type.any))

# recognize email addresses and phone numbers as strings
(rule $PhoneNumber ($PHRASE) (NerValueFn PHONE_NUMBER) (anchored 1))
(rule $PhoneNumberValue ($PhoneNumber) (lambda v (call @phoneNumberCast (var v))))
# optimization: email addresses are always single token
(rule $EmailAddress ($TOKEN) (NerValueFn EMAIL_ADDRESS) (anchored 1))
(rule $EmailAddressValue ($EmailAddress) (lambda v (call @emailAddressCast (var v))))

(rule $PeriodicTimeValue ($PHRASE) (thingtalk.TimeDurationFn) (anchored 1))
(rule $PeriodicTimeValue (@every $TimeIntervalValue) (SelectFn 0))

(def @all_values ($DateValue $TimeValue $NumValue
$MeasureValue $TimeIntervalValue $BooleanValue $LocationValue
$PhoneNumberValue $EmailAddressValue $StringValue))

# Answer handling
# NOTE 1: string answers are handled by putting Sabrina in "raw" mode
# which bypasses sempre
# DO NOT put $Answer -> $StringValue here, it would catch everything and confuse the parser
# NOTE 2: boolean answers are matched to yes/no, which are specials
# but you still need to handle them here to match synonyms of true/false like on/off
# that should not be learned as synonyms of yes/no
(def @answer_values ($DateValue $TimeValue $NumValue
$MeasureValue $TimeIntervalValue $BooleanValue $LocationValue
$PhoneNumberValue $EmailAddressValue))

# FIXME: Integrate this to improve the canonicals
#(rule $PersonValue ($PHRASE) (FilterNerSpanFn PERSON) (anchored 1))
#(rule $OrgValue ($PHRASE) (FilterNerSpanFn ORGANIZATION) (anchored 1))

# operators
# DO NOT replace this with SimpleLexiconFn or similar: FloatingParser
# must see all the rules to generate all the ops
(rule $Op (@is) (ConstantFn (string is)))
(rule $Op (@contains) (ConstantFn (string contains)))
(rule $Op @is_greater_than (ConstantFn (string ">")))
(rule $Op @is_less_than (ConstantFn (string "<")))
(rule $Op (@has) (ConstantFn (string has)))

(rule $WithArg (@with arg) (ConstantFn null))

# Action Handling
(rule $ActionName ($TOKEN) (thingtalk.ThingpediaLexiconFn @language_tag action) (anchored 1))
(rule $Action ($ActionName) (lambda act (call @actParam (var act))))
(rule $ActionWithArg ($Action $WithArg) (thingtalk.ApplyFn action))
(rule $ActionIntermediate ($ActionWithArg $Op) (thingtalk.AddOperatorFn action))
(for @v @all_values
	(rule $Action ($ActionIntermediate @v) (thingtalk.AddValueFn))
)

(rule $TriggerName ($TOKEN) (thingtalk.ThingpediaLexiconFn @language_tag trigger) (anchored 1))
(rule $Trigger ($TriggerName) (lambda trig (call @trigParam (var trig))))
(rule $TriggerWithArg ($Trigger $WithArg) (thingtalk.ApplyFn trigger))
(rule $TriggerIntermediate ($TriggerWithArg $Op) (thingtalk.AddOperatorFn trigger))
(for @v @all_values
	(rule $Trigger ($TriggerIntermediate @v) (thingtalk.AddValueFn))
)

(rule $QueryName ($TOKEN) (thingtalk.ThingpediaLexiconFn @language_tag query) (anchored 1))
(rule $Query ($QueryName) (lambda query (call @queryParam (var query))))
(rule $QueryWithArg ($Query $WithArg) (thingtalk.ApplyFn query))
(rule $QueryIntermediate ($QueryWithArg $Op) (thingtalk.AddOperatorFn query))
(for @v @all_values
	(rule $Query ($QueryIntermediate @v) (thingtalk.AddValueFn))
)

(rule $MonitorIf @monitor_if (ConstantFn (string "")))
(rule $Notify ($MonitorIf $Trigger) (SelectFn 1))

(rule $TimeRulePrefix @every_day_at (ConstantFn (string "")))
(rule $TimeTrigger ($TimeRulePrefix $TimeValue) (SelectFn 1))

(rule $TimeQueryRule  ($TimeTrigger $Query)               (thingtalk.CallFn @timeRule))
(rule $TimeActionRule ($TimeTrigger $Action)              (thingtalk.CallFn @timeRule))
(rule $TimeQueryRule  ($PeriodicTimeValue $Query)         (thingtalk.CallFn @timeSpanRule))
(rule $TimeActionRule ($PeriodicTimeValue $Action)        (thingtalk.CallFn @timeSpanRule))
(rule $TimeActionRule ($TimeQueryRule @then $Action)      (thingtalk.CallFn @ifttt))

# manually binarize rule meaningfully
(rule $IfTrigger       (@if $Trigger) (SelectFn 0))
(rule $IfTriggerThen   ($IfTrigger @then)  (SelectFn 0))
(rule $IftttQueryRule  ($IfTriggerThen $Query)            (thingtalk.CallFn @ifttt))
(rule $IftttActionRule ($IfTriggerThen $Action)           (thingtalk.CallFn @ifttt))
(rule $IftttActionRule ($IftttQueryRule @then $Action)    (thingtalk.CallFn @ifttt))
(rule $IftttChain      ($Query @then $Action)        (thingtalk.CallFn @ifttt))

# the following rules are very very tricky
# they deal with "with foo is that" passing of arguments from trigger to action
# and they rely on the precise binarization of the grammar to have correct canonicals
# in particular, the binarized grammar will include an intermediate binary rule with SelectFn 0
# and an unary cat rule with AddCompositionFn
# AddCompositionFn takes care of adding the "foo is that" part
(rule $TimeQueryRule   ($TimeQueryRule @with)            (thingtalk.AddCompositionFn query @is))
(rule $TimeActionRule  ($TimeActionRule @with)           (thingtalk.AddCompositionFn action @is))
(rule $IftttQueryRule  ($IftttQueryRule @with)           (thingtalk.AddCompositionFn query @is))
(rule $IftttActionRule ($IftttActionRule @with)          (thingtalk.AddCompositionFn action @is))
(rule $IftttChain      ($IftttChain @with)               (thingtalk.AddCompositionFn action @is))

(rule $Device ($TOKEN) (thingtalk.ThingpediaLexiconFn @language_tag kind) (anchored 1))

(rule $Help (@help) (ConstantFn (string generic)))
(rule $Help (@help $Device) (IdentityFn))

(rule $Discovery (@discover) (ConstantFn (string generic)))
(rule $Discovery (@discover $Device) (IdentityFn))

(rule $Configuration (@configure) (ConstantFn (string generic)))
(rule $Configuration (@configure $Device) (IdentityFn))

(rule $Information (@list) (ConstantFn (string generic)))
(rule $Information (@list @devices) (ConstantFn (string device)))
(rule $Information (@list @queries) (ConstantFn (string query)))
(rule $Information (@list @commands) (ConstantFn (string command)))

# Command handling
(rule $Command ($Help) (lambda value (call @cmdForm (string "help") (var value))))
(rule $Command ($Discovery) (lambda value (call @cmdForm (string "discover") (var value))))
(rule $Command ($Information) (lambda value (call @cmdForm (string "list") (var value))))
(rule $Command ($Configuration) (lambda value (call @cmdForm (string "configure") (var value))))

# special handling
# this used to be in SimpleLexicon but we moved it here for two reasons:
# 1) FloatingParser and SimpleLexicon do not like each other, meaning that you need
# to use the exact words in the lexicon for FloatingParser to parse properly (regardless of
# paraphrases)
# 2) It's easier to translate like this, and we don't need to teach SimpleLexicon
# about language tags
(rule $Special (@yes) (ConstantFn tt:root.special.yes))
(rule $Special (@no) (ConstantFn tt:root.special.no))
(rule $Special (@hello) (ConstantFn tt:root.special.hello))
(rule $Special (@thanks) (ConstantFn tt:root.special.thankyou))
(rule $Special (@sorry) (ConstantFn tt:root.special.sorry))
(rule $Special (@cool) (ConstantFn tt:root.special.cool))
(rule $Special @never_mind (ConstantFn tt:root.special.nevermind))
# this is a literal, it is not translated
(rule $Special (debug) (ConstantFn tt:root.special.debug))
# this is a special token that should never be matched
# it represents the failure to parse meaningfully (which triggers
# fallbacks on the client side)
(rule $Special (failuretoparse) (ConstantFn tt:root.special.failed))

(for @v @answer_values
	(rule $Answer (@v) (lambda value (call @ansForm (var value))))
)

(for @v ($Command $Action $Notify $Query $Answer $TimeQueryRule $TimeActionRule $IftttActionRule $IftttQueryRule $IftttChain)
	(rule $ROOT (@v) (lambda cmd (call @jsonOut (var cmd))))
)
(rule $ROOT ($Special) (lambda spl (call @special (var spl))))

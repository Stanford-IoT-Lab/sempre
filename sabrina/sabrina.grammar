# JavaExecutor Functions
(def @measureValueCast edu.stanford.nlp.sempre.thingtalk.ThingTalk.measureValueCast)

(def @paramForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.paramForm)

(def @trigParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.trigParam)
(def @queryParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.queryParam)
(def @actParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.actParam)

(def @timeRule edu.stanford.nlp.sempre.thingtalk.ThingTalk.timeRule)
(def @timeSpanRule edu.stanford.nlp.sempre.thingtalk.ThingTalk.timeSpanRule)

(def @cmdForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.cmdForm)

(def @ansForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.ansForm)

(def @jsonOut edu.stanford.nlp.sempre.thingtalk.ThingTalk.jsonOut)

(def @special edu.stanford.nlp.sempre.thingtalk.ThingTalk.special)

# Value Parsing
(rule $NumValue ($PHRASE) (NumberFn) (anchored 1))
(rule $DateValue ($PHRASE) (DateFn) (anchored 1))
(rule $TimeValue ($PHRASE) (TimeFn) (anchored 1))
(rule $NumberValue ($NumValue) (IdentityFn))
(rule $TemperatureValue ($NumValue c) (lambda num (call @measureValueCast (string "C") (var num))))
(rule $TemperatureValue ($NumValue f) (lambda num (call @measureValueCast (string "F") (var num))))
(rule $TimeIntervalValue ($NumValue s) (lambda num (call @measureValueCast (string "s") (var num))))
(rule $TimeIntervalValue ($NumValue min) (lambda num (call @measureValueCast (string "min") (var num))))
(rule $TimeIntervalValue ($NumValue h) (lambda num (call @measureValueCast (string "h") (var num))))
(rule $TimeIntervalValue ($NumValue day) (lambda num (call @measureValueCast (string "day") (var num))))
(rule $TimeIntervalValue ($NumValue week) (lambda num (call @measureValueCast (string "week") (var num))))
(rule $TimeIntervalValue ($NumValue month) (lambda num (call @measureValueCast (string "mon") (var num))))
(rule $TimeIntervalValue ($NumValue year) (lambda num (call @measureValueCast (string "year") (var num))))
(rule $BooleanValue (@true) (ConstantFn (boolean true)))
(rule $BooleanValue (@false) (ConstantFn (boolean false)))
(rule $StrValue ($PHRASE) (IdentityFn) (anchored 1))
(when floatingstrings
	(rule $StringValue (`` $StrValue '') (IdentityFn))
)
(when not floatingstrings
	(rule $StringValue (`` $StrValue '') (IdentityFn) (anchored 1))
)
# work around someweirdness in the corenlp tokenizer
# this is always anchored because it deals with explicitly added quotes
(rule $StringValue ('' $StrValue '') (IdentityFn) (anchored 1))
(rule $Value ($DateValue) (IdentityFn))
(rule $Value ($TimeValue) (IdentityFn))
(rule $Value ($NumberValue) (IdentityFn))
(rule $Value ($TemperatureValue) (IdentityFn))
(rule $Value ($BooleanValue) (IdentityFn))
(rule $Value ($StringValue) (IdentityFn))

(rule $LocationValue ($PHRASE) (thingtalk.LocationLexiconFn) (anchored 1))
(rule $LocationValue (here) (ConstantFn (location rel_current_location -1 -1) fb:type.any))
(rule $LocationValue (at home) (ConstantFn (location rel_home -1 -1) fb:type.any))
(rule $LocationValue (at work) (ConstantFn (location rel_work -1 -1) fb:type.any))

# FIXME: Integrate this to improve the canonicals
#(rule $PersonValue ($PHRASE) (FilterNerSpanFn PERSON) (anchored 1))
#(rule $OrgValue ($PHRASE) (FilterNerSpanFn ORGANIZATION) (anchored 1))

# Argument Names
(when floatingargs
    # what this rule maps to is just a placeholder: ThingpediaLexiconFn recognizes
    # when it is called in floating mode, and generates all possible parameters
    # furthermore, the lexicon entries have their canonical already specified so
    # arg just disappears
	(rule $StringArgName (arg) (thingtalk.ThingpediaLexiconFn param String floating))
	(rule $DateArgName (arg) (thingtalk.ThingpediaLexiconFn param Date floating))
	(rule $TimeArgName (arg) (thingtalk.ThingpediaLexiconFn param String floating))
	(rule $NumberArgName (arg) (thingtalk.ThingpediaLexiconFn param Number floating))
	(rule $TemperatureArgName (arg) (thingtalk.ThingpediaLexiconFn param "Measure(C)" floating))
	(rule $TimeIntervalArgName (arg) (thingtalk.ThingpediaLexiconFn param "Measure(ms)" floating))
	(rule $BooleanArgName (arg) (thingtalk.ThingpediaLexiconFn param Boolean floating))
	(rule $LocationArgName (arg) (thingtalk.ThingpediaLexiconFn param Location floating))
	(rule $ArrayStringArgName (arg) (thingtalk.ThingpediaLexiconFn param "Array(String)" floating))
)
(when (not floatingargs)
	(rule $StringArgName ($PHRASE) (thingtalk.ThingpediaLexiconFn param String))
	(rule $DateArgName ($PHRASE) (thingtalk.ThingpediaLexiconFn param Date))
	(rule $TimeArgName ($PHRASE) (thingtalk.ThingpediaLexiconFn param String))
	(rule $NumberArgName ($PHRASE) (thingtalk.ThingpediaLexiconFn param Number))
	(rule $TemperatureArgName ($PHRASE) (thingtalk.ThingpediaLexiconFn param "Measure(C)"))
	(rule $TimeIntervalArgName ($PHRASE) (thingtalk.ThingpediaLexiconFn param "Measure(ms)"))
	(rule $BooleanArgName ($PHRASE) (thingtalk.ThingpediaLexiconFn param Boolean))
	(rule $LocationArgName ($PHRASE) (thingtalk.ThingpediaLexiconFn param Location))
	(rule $ArrayStringArgName ($PHRASE) (thingtalk.ThingpediaLexiconFn param "Array(String)"))
)

# operators
# DO NOT replace this with SimpleLexiconFn or similar: FloatingParser
# must see all the rules to generate all the ops
(rule $GenericOp (@is) (ConstantFn (string is)))
(rule $StringOp (@is) (ConstantFn (string is)))
(rule $StringOp (@contains) (ConstantFn (string contains)))
(rule $NumericOp (@is) (ConstantFn (string is)))
(rule $NumericOp @is_greater_than (ConstantFn (string ">")))
(rule $NumericOp @is_less_than (ConstantFn (string "<")))
(rule $ArrayOp (@has) (ConstantFn (string has)))

# Arguments
(rule $Arg ($StringArgName $StringOp $StringValue) (lambda arg (lambda op (lambda value (call @paramForm (var arg) (var op) (var value))))))
(rule $Arg ($DateArgName $GenericOp $DateValue) (lambda arg (lambda op (lambda value (call @paramForm (var arg) (var op) (var value))))))
(rule $Arg ($TimeArgName $GenericOp $TimeValue) (lambda arg (lambda op (lambda value (call @paramForm (var arg) (var op) (var value))))))
(rule $Arg ($NumberArgName $NumericOp $NumberValue) (lambda arg (lambda op (lambda value (call @paramForm (var arg) (var op) (var value))))))
(rule $Arg ($TemperatureArgName $NumericOp $TemperatureValue) (lambda arg (lambda op (lambda value (call @paramForm (var arg) (var op) (var value))))))
(rule $Arg ($TimeIntervalArgName $NumericOp $TimeIntervalValue) (lambda arg (lambda op (lambda value (call @paramForm (var arg) (var op) (var value))))))
(rule $Arg ($BooleanArgName $GenericOp $BooleanValue) (lambda arg (lambda op (lambda value (call @paramForm (var arg) (var op) (var value))))))
(rule $Arg ($LocationArgName $GenericOp $LocationValue) (lambda arg (lambda op (lambda value (call @paramForm (var arg) (var op) (var value))))))
(rule $Arg ($ArrayStringArgName $ArrayOp $StringValue) (lambda arg (lambda op (lambda value (call @paramForm (var arg) (var op) (var value))))))
(rule $ValidArg ($Arg) (thingtalk.FilterInvalidArgFn))

# Action Handling
(when floatingnames
	(rule $ActionName ($TOKEN) (thingtalk.ThingpediaLexiconFn action))
)
(when (not floatingnames)
	(rule $ActionName ($PHRASE) (thingtalk.ThingpediaLexiconFn action))
)
(rule $Action ($ActionName) (lambda act (call @actParam (var act))))
(rule $Action ($Action @with $ValidArg) (lambda act (lambda arg (call @actParam (var act) (var arg)))))
(rule $ValidAction ($Action) (thingtalk.FilterInvalidInvocationFn))

(when floatingnames
	(rule $TriggerName ($TOKEN) (thingtalk.ThingpediaLexiconFn trigger))
)
(when (not floatingnames)
	(rule $TriggerName ($PHRASE) (thingtalk.ThingpediaLexiconFn trigger))
)
(rule $Trigger ($TriggerName) (lambda trig (call @trigParam (var trig))))
(rule $Trigger ($Trigger @and $ValidArg) (lambda trig (lambda arg (call @trigParam (var trig) (var arg)))))
(rule $ValidTrigger ($Trigger) (thingtalk.FilterInvalidInvocationFn))

(when floatingnames
	(rule $QueryName ($TOKEN) (thingtalk.ThingpediaLexiconFn query))
)
(when (not floatingnames)
	(rule $QueryName ($PHRASE) (thingtalk.ThingpediaLexiconFn query))
)
(rule $Query ($QueryName) (lambda query (call @queryParam (var query))))
(rule $Query ($Query and $ValidArg) (lambda query (lambda arg (call @queryParam (var query) (var arg)))))
(rule $ValidQuery ($Query) (thingtalk.FilterInvalidInvocationFn))

(rule $MonitorIf @monitor_if (ConstantFn (string "")))
(rule $Notify ($MonitorIf $ValidTrigger) (SelectFn 1))

(rule $ValidActionOrQuery ($ValidAction) (IdentityFn))
(rule $ValidActionOrQuery ($ValidQuery) (IdentityFn))
(rule $TimeRule (every day at $TimeValue $ValidActionOrQuery) (lambda time (lambda action (call @timeRule (var time) (var action)))))
(rule $TimeRule (every $TimeIntervalValue $ValidActionOrQuery) (lambda time (lambda action (call @timeSpanRule (var time) (var action)))))

(rule $Device ($TOKEN) (thingtalk.ThingpediaLexiconFn kind) (anchored 1))

(rule $Help (@help) (ConstantFn (string generic)) (anchored 1))
(rule $Help (@help $Device) (IdentityFn))

(rule $Discovery (@discover) (ConstantFn (string generic)))
(rule $Discovery (@discover $Device) (IdentityFn))

(rule $Configuration (@configure) (ConstantFn (string generic)))
(rule $Configuration (@configure $Device) (IdentityFn))

(rule $Listing (@devices) (ConstantFn (string device)))
(rule $Listing (@queries) (ConstantFn (string query)))
(rule $Listing (@commands) (ConstantFn (string command)))

(rule $Information (@list) (ConstantFn (string generic)))
(rule $Information (@list $Listing) (IdentityFn))

# Command handling
(rule $Command ($Help) (lambda value (call @cmdForm (string "help") (var value))))
(rule $Command ($Discovery) (lambda value (call @cmdForm (string "discover") (var value))))
(rule $Command ($Information) (lambda value (call @cmdForm (string "list") (var value))))
(rule $Command ($Configuration) (lambda value (call @cmdForm (string "configure") (var value))))

# special handling
# this used to be in SimpleLexicon but we moved it here for two reasons:
# 1) FloatingParser and SimpleLexicon do not like each other, meaning that you need
# to use the exact words in the lexicon for FloatingParser to parse properly (regardless of
# paraphrases)
# 2) It's easier to translate like this, and we don't need to teach SimpleLexicon
# about language tags
(rule $Special (@yes) (ConstantFn tt:root.special.yes))
(rule $Special (@no) (ConstantFn tt:root.special.no))
(rule $Special (@hello) (ConstantFn tt:root.special.hello))
(rule $Special (@thanks) (ConstantFn tt:root.special.thankyou))
(rule $Special (@sorry) (ConstantFn tt:root.special.sorry))
(rule $Special (@cool) (ConstantFn tt:root.special.cool))
(rule $Special @never_mind (ConstantFn tt:root.special.nevermind))
# this is a literal, it is not translated
(rule $Special (debug) (ConstantFn tt:root.special.debug))

# Answer handling
# NOTE 1: string answers are handled by putting Sabrina in "raw" mode
# which bypasses sempre
# DO NOT put $Answer -> $StringValue here, it would catch everything and confuse the parser
# NOTE 2: boolean answers are matched to yes/no, which are specials
# but you still need to handle them here to match synonyms of true/false like on/off
# that should not be learned as synonyms of yes/no
(rule $Answer ($DateValue) (lambda value (call @ansForm (var value))))
(rule $Answer ($TimeValue) (lambda value (call @ansForm (var value))))
(rule $Answer ($NumberValue) (lambda value (call @ansForm (var value))))
(rule $Answer ($TemperatureValue) (lambda value (call @ansForm (var value))))
(rule $Answer ($BooleanValue) (lambda value (call @ansForm (var value))))
(rule $Answer ($LocationValue) (lambda value (call @ansForm (var value))))

(rule $ROOT ($Command) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($ValidAction) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Notify) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($ValidQuery) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Answer) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($TimeRule) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Special) (lambda spl (call @special (var spl))))

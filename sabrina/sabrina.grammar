# JavaExecutor Functions
(def @tempValueCast edu.stanford.nlp.sempre.thingtalk.ThingTalk.tempValueCast)

(def @paramForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.paramForm)

(def @trigParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.trigParam)
(def @queryParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.queryParam)
(def @actParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.actParam)

(def @cmdForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.cmdForm)

(def @ansForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.ansForm)

(def @jsonOut edu.stanford.nlp.sempre.thingtalk.ThingTalk.jsonOut)

(def @special edu.stanford.nlp.sempre.thingtalk.ThingTalk.special)

# Value Parsing
(rule $DateValue ($PHRASE) (DateFn) (anchored 1))
(rule $TimeValue ($PHRASE) (TimeFn) (anchored 1))
(rule $StringValue ($PHRASE) (IdentityFn) (anchored 1))
(rule $NumValue ($PHRASE) (NumberFn) (anchored 1))
(rule $TempValue ($NumValue c) (lambda num (call @tempValueCast (string "C") (var num))))
(rule $TempValue ($NumValue f) (lambda num (call @tempValueCast (string "F") (var num))))
(rule $BoolValue (true) (ConstantFn (boolean true)))
(rule $BoolValue (false) (ConstantFn (boolean false)))

(rule $LocationValue ($PHRASE) (thingtalk.LocationLexiconFn))
(rule $LocationValue (here) (ConstantFn (location rel_current_location -1 -1) fb:type.any))
(rule $LocationValue (at home) (ConstantFn (location rel_home -1 -1) fb:type.any))
(rule $LocationValue (at work) (ConstantFn (location rel_work -1 -1) fb:type.any))

# FIXME: Integrate this to improve the canonicals
#(rule $PersonValue ($PHRASE) (FilterNerSpanFn PERSON) (anchored 1))
#(rule $OrgValue ($PHRASE) (FilterNerSpanFn ORGANIZATION) (anchored 1))

# Argument Names
(rule $ArgName ($PHRASE) (thingtalk.ThingpediaLexiconFn param))

# Operator parsing
(rule $Op (is) (ConstantFn (string "is")))

(rule $StringOp (contains) (ConstantFn (string "contains")))
(rule $StringOp (is) (ConstantFn (string "is")))

(rule $NumOp (is) (ConstantFn (string "is")))
(rule $NumOp (is greater than) (ConstantFn (string ">")))
(rule $NumOp (is lesser than) (ConstantFn (string "<")))

(rule $ArrayOp (has) (ConstantFn (string "has")))

# Handling different types
(rule $StringArg ($ArgName $StringOp $StringValue) (lambda arg (lambda op (lambda value (call @paramForm (string "String") (var arg) (var op) (var value))))))
(rule $ArrayArg ($ArgName $ArrayOp $StringValue) (lambda arg (lambda op (lambda value (call @paramForm (string "String") (var arg) (var op) (var value))))))
(rule $DateArg ($ArgName $Op $DateValue) (lambda arg (lambda value (lambda op (call @paramForm (string "Date") (var arg) (var op) (var value))))))
(rule $TimeArg ($ArgName $Op $TimeValue) (lambda arg (lambda op (lambda value (call @paramForm (string "Time") (var arg) (var op) (var value))))))
(rule $BoolArg ($ArgName $Op $BoolValue) (lambda arg (lambda op (lambda value (call @paramForm (string "Bool") (var arg) (var op) (var value))))))
(rule $NumArg ($ArgName $NumOp $NumValue) (lambda arg (lambda op (lambda value (call @paramForm (string "Number") (var arg) (var op) (var value))))))
(rule $TempArg ($ArgName $NumOp $TempValue) (lambda arg (lambda op (lambda value (call @paramForm (string "Measure") (var arg) (var op) (var value))))))
(rule $LocationArg ($ArgName $Op $LocationValue) (lambda arg (lambda op (lambda value (call @paramForm (string "Location") (var arg) (var op) (var value))))))

# Arguments
(rule $Arg ($StringArg) (thingtalk.FilterInvalidArgFn))
(rule $Arg ($ArrayArg) (thingtalk.FilterInvalidArgFn))
(rule $Arg ($DateArg) (thingtalk.FilterInvalidArgFn))
(rule $Arg ($TimeArg) (thingtalk.FilterInvalidArgFn))
(rule $Arg ($BoolArg) (thingtalk.FilterInvalidArgFn))
(rule $Arg ($NumArg) (thingtalk.FilterInvalidArgFn))
(rule $Arg ($TempArg) (thingtalk.FilterInvalidArgFn))
(rule $Arg ($LocationArg) (thingtalk.FilterInvalidArgFn))
#(rule $Arg ($StringArg) (IdentityFn))
#(rule $Arg ($ArrayArg) (IdentityFn))
#(rule $Arg ($DateArg) (IdentityFn))
#(rule $Arg ($TimeArg) (IdentityFn))
#(rule $Arg ($BoolArg) (IdentityFn))
#(rule $Arg ($NumArg) (IdentityFn))
#(rule $Arg ($TempArg) (IdentityFn))

# Action Handling
(rule $ActionName ($PHRASE) (thingtalk.ThingpediaLexiconFn action))

(rule $Action0 ($ActionName) (lambda act (call @actParam (var act))))
(rule $Action1 ($Action0 with $Arg) (lambda act (lambda arg (call @actParam (var act) (var arg)))))
(rule $Action2 ($Action1 with $Arg) (lambda act (lambda arg (call @actParam (var act) (var arg)))))
(rule $Action3 ($Action2 with $Arg) (lambda act (lambda arg (call @actParam (var act) (var arg)))))

(rule $Action ($Action0) (thingtalk.FilterInvalidInvocationFn))
(rule $Action ($Action1) (thingtalk.FilterInvalidInvocationFn))
(rule $Action ($Action2) (thingtalk.FilterInvalidInvocationFn))
(rule $Action ($Action3) (thingtalk.FilterInvalidInvocationFn))
#(rule $Action ($Action0) (IdentityFn))
#(rule $Action ($Action1) (IdentityFn))
#(rule $Action ($Action2) (IdentityFn))
#(rule $Action ($Action3) (IdentityFn))

(rule $TriggerName ($PHRASE) (thingtalk.ThingpediaLexiconFn trigger))

(rule $Trigger0 ($TriggerName) (lambda trig (call @trigParam (var trig))))
(rule $Trigger1 ($Trigger0 and $Arg) (lambda trig (lambda arg (call @trigParam (var trig) (var arg)))))
(rule $Trigger2 ($Trigger1 and $Arg) (lambda trig (lambda arg (call @trigParam (var trig) (var arg)))))
(rule $Trigger3 ($Trigger2 and $Arg) (lambda trig (lambda arg (call @trigParam (var trig) (var arg)))))

(rule $Trigger ($Trigger0) (thingtalk.FilterInvalidInvocationFn))
(rule $Trigger ($Trigger1) (thingtalk.FilterInvalidInvocationFn))
(rule $Trigger ($Trigger2) (thingtalk.FilterInvalidInvocationFn))
(rule $Trigger ($Trigger3) (thingtalk.FilterInvalidInvocationFn))
#(rule $Trigger ($Trigger0) (IdentityFn))
#(rule $Trigger ($Trigger1) (IdentityFn))
#(rule $Trigger ($Trigger2) (IdentityFn))
#(rule $Trigger ($Trigger3) (IdentityFn))

(rule $QueryName ($PHRASE) (thingtalk.ThingpediaLexiconFn query))

(rule $Query0 ($QueryName) (lambda query (call @queryParam (var query))))
(rule $Query1 ($Query0 and $Arg) (lambda query (lambda arg (call @queryParam (var query) (var arg)))))
(rule $Query2 ($Query1 and $Arg) (lambda query (lambda arg (call @queryParam (var query) (var arg)))))
(rule $Query3 ($Query2 and $Arg) (lambda query (lambda arg (call @queryParam (var query) (var arg)))))

(rule $Query ($Query0) (thingtalk.FilterInvalidInvocationFn))
(rule $Query ($Query1) (thingtalk.FilterInvalidInvocationFn))
(rule $Query ($Query2) (thingtalk.FilterInvalidInvocationFn))
(rule $Query ($Query3) (thingtalk.FilterInvalidInvocationFn))
#(rule $Query ($Query0) (IdentityFn))
#(rule $Query ($Query1) (IdentityFn))
#(rule $Query ($Query2) (IdentityFn))
#(rule $Query ($Query3) (IdentityFn))

(rule $Notify (monitor if $Trigger) (IdentityFn))

(rule $Device ($TOKEN) (thingtalk.ThingpediaLexiconFn kind))

(rule $Help (help) (ConstantFn (string generic)) (anchored 1))
(rule $Help (help $Device) (IdentityFn))

(rule $Discovery (discover) (ConstantFn (string generic)))
(rule $Discovery (discover $Device) (IdentityFn))

(rule $Configuration (configure) (ConstantFn (string generic)))
(rule $Configuration (configure $Device) (IdentityFn))

(rule $Listing (devices) (ConstantFn (string device)))
(rule $Listing (queries) (ConstantFn (string query)))
(rule $Listing (commands) (ConstantFn (string command)))

(rule $Information (list) (ConstantFn (string generic)))
(rule $Information (list $Listing) (IdentityFn))

# Command handling
(rule $Command ($Help) (lambda value (call @cmdForm (string "help") (var value))))
(rule $Command ($Discovery) (lambda value (call @cmdForm (string "discover") (var value))))
(rule $Command ($Information) (lambda value (call @cmdForm (string "list") (var value))))
(rule $Command ($Configuration) (lambda value (call @cmdForm (string "configure") (var value))))

(rule $Special ($PHRASE) (SimpleLexiconFn (type tt:type.special)))

# Answer handling
# NOTE 1: string answers are handled by putting Sabrina in "raw" mode
# which bypasses sempre
# DO NOT put $Answer -> $StringValue here, it would catch everything and confuse the parser
# NOTE 2: boolean answers are matched to yes/no, which are specials
# but you still need to handle them here to match synonyms of true/false like on/off
# that should not be learned as synonyms of yes/no
(rule $Answer ($DateValue) (lambda value (call @ansForm (string "Date") (var value))))
(rule $Answer ($TimeValue) (lambda value (call @ansForm (string "Time") (var value))))
(rule $Answer ($NumValue) (lambda value (call @ansForm (string "Number") (var value))))
(rule $Answer ($TempValue) (lambda value (call @ansForm (string "Measure") (var value))))
(rule $Answer ($BoolValue) (lambda value (call @ansForm (string "Bool") (var value))))
(rule $Answer ($LocationValue) (lambda value (call @ansForm (string "Location") (var value))))

(rule $ROOT ($Command) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Action) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Notify) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Query) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Answer) (lambda cmd (call @jsonOut (var cmd))))
(rule $ROOT ($Special) (lambda spl (call @special (var spl))))

# JavaExecutor Functions
(def @stringValueCast edu.stanford.nlp.sempre.thingtalk.ThingTalk.stringValueCast)
(def @numValueCast edu.stanford.nlp.sempre.thingtalk.ThingTalk.numValueCast)
(def @tempValueCast edu.stanford.nlp.sempre.thingtalk.ThingTalk.tempValueCast)
(def @boolValueCast edu.stanford.nlp.sempre.thingtalk.ThingTalk.boolValueCast)
(def @paramForm edu.stanford.nlp.sempre.thingtalk.ThingTalk.paramForm)

(def @trigParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.trigParam)
(def @actParam edu.stanford.nlp.sempre.thingtalk.ThingTalk.actParam)

(def @ifttt edu.stanford.nlp.sempre.thingtalk.ThingTalk.ifttt)
(def @jsonOut edu.stanford.nlp.sempre.thingtalk.ThingTalk.jsonOut)

#(def @paramTop edu.stanford.nlp.sempre.thingtalk.ThingTalk.paramTop)
(def @special edu.stanford.nlp.sempre.thingtalk.ThingTalk.special)
#(def @toSparqlQuestion   edu.stanford.nlp.sempre.thingtalk.SparqlConverter.executeAndWrap)

# String -> PHRASE
(when parse
    (rule $DateValue ($PHRASE) (DateFn) (anchored 1))
    (rule $TimeValue ($PHRASE) (TimeFn) (anchored 1))

    # For avoiding polymorphic function excesses
    (rule $StringParseValue ($PHRASE) (IdentityFn) (anchored 1))
    (rule $StringValue ($StringParseValue) (lambda string (call @stringValueCast (var string))))

    (rule $NumParseValue ($PHRASE) (NumberFn) (anchored 1))
    (rule $NumValue ($NumParseValue) (lambda num (call @numValueCast (var num))))

    (rule $TempValue ($NumParseValue c) (lambda num (call @tempValueCast (string "C") (var num))))
    (rule $TempValue ($NumParseValue f) (lambda num (call @tempValueCast (string "F") (var num))))

    (rule $BoolParseValue (true) (ConstantFn (string true)) (anchored 1))
    (rule $BoolParseValue (false) (ConstantFn (string false)) (anchored 1))
    (rule $BoolValue ($BoolParseValue) (lambda bool (call @boolValueCast (var bool))))

    # FIXME: Integrate this to improve the canonicals
    (rule $PlaceValue ($PHRASE) (FilterNerSpanFn LOCATION) (anchored 1))
    (rule $PersonValue ($PHRASE) (FilterNerSpanFn PERSON) (anchored 1))
    (rule $OrgValue ($PHRASE) (FilterNerSpanFn ORGANIZATION) (anchored 1))
)

(when generate
    (rule $StringValue (new post) (ConstantFn (string "new post")))
    (rule $StringValue (new dm) (ConstantFn (string "new dm")))

    (rule $DateValue (February 28) (ConstantFn (date -1 2 28)))
    (rule $DateValue (New Year 2017) (ConstantFn (date 2017 1 1)))
    (rule $DateValue (the 1st) (ConstantFn (date -1 -1 1)))

    (rule $TimeValue (midnight) (ConstantFn (time 0 0)))
    (rule $TimeValue (12 noon) (ConstantFn (time 12 0)))
    (rule $TimeValue (6:30am) (ConstantFn (time 6 30)))

    (rule $BoolValue (true) (ConstantFn (boolean "true")))
    (rule $BoolValue (false) (ConstantFn (boolean "false")))

    (rule $NumValue (twenty two) (ConstantFn (number 22)))
    (rule $NumValue (50) (ConstantFn (number 50)))
    (rule $NumValue (80) (ConstantFn (number 80)))
    (rule $NumValue (20) (ConstantFn (number 20)))
    (rule $NumValue (hundred) (ConstantFn (number 100)))

    (rule $PersonValue (Giovanni) (ConstantFn (string "Giovanni")))
    (rule $PersonValue (Xiangyu) (ConstantFn (string "Xiangyu")))

    (rule $PlaceValue (Stanford) (ConstantFn (string "Stanford")))
    (rule $PlaceValue (San Francisco) (ConstantFn (string "San Francisco")))

    (rule $OrgValue (Google) (ConstantFn (string "Google")))
    (rule $OrgValue (Walmart) (ConstantFn (string "Walmart")))
)

# FIXME: Try to incorporate this somehow
# Special Parameters -> String | Number | from PERSON | to PERSON | on DATE | at TIME | at PLACE
#    (rule $Param (on $DateValue) (lambda date (call @paramForm (string "on") (string "Date") (var date))))
#    (rule $Param (at $TimeValue) (lambda time (call @paramForm (string "at") (string "Time") (var time))))
#    (rule $Param (at $PlaceValue) (lambda place (call @paramForm (string "at") (string "String") (var place))))
#    (rule $Param (from $PersonValue) (lambda person (call @paramForm (string "from") (string "String") (var person))))
#    (rule $Param (to $PersonValue) (lambda person (call @paramForm (string "to") (string "String") (var person))))
#    (rule $Param (in $OrgValue) (lambda organization (call @paramForm (string "in") (string "String") (var organization))))
#)

# Arg is simple for now
# Arg -> StringArg | DateArg | TimeArg | BoolArg
(when (or parse generate)

    # Argument Names
    (rule $StringArgName ($PHRASE) (SimpleLexiconFn (type tt:type.stringarg)))
    (rule $ArrayArgName ($PHRASE) (SimpleLexiconFn (type tt:type.arrayarg)))
    (rule $DateArgName ($PHRASE) (SimpleLexiconFn (type tt:type.datearg)))
    (rule $TimeArgName ($PHRASE) (SimpleLexiconFn (type tt:type.timearg)))
    (rule $BoolArgName ($PHRASE) (SimpleLexiconFn (type tt:type.boolarg)))
    (rule $NumArgName ($PHRASE) (SimpleLexiconFn (type tt:type.numarg)))
    (rule $TempArgName ($PHRASE) (SimpleLexiconFn (type tt:type.temparg)))

    # Operator parsing
    (rule $Op (is) (ConstantFn (string "is")))

    (rule $StringOp (contains) (ConstantFn (string "contains")))
    (rule $StringOp (is) (ConstantFn (string "is")))

    (rule $NumOp (is) (ConstantFn (string "is")))
    (rule $NumOp (is greater than) (ConstantFn (string ">")))
    (rule $NumOp (is lesser than) (ConstantFn (string "<")))

    (rule $ArrayOp (has) (ConstantFn (string "has")))

    # Handling different types
    (rule $StringArg ($StringArgName $StringOp $StringValue) (lambda arg (lambda op (lambda value (call @paramForm (string "String") (var arg) (var op) (var value))))))
    (rule $ArrayArg ($ArrayArgName $ArrayOp $StringValue) (lambda arg (lambda op (lambda value (call @paramForm (string "String") (var arg) (var op) (var value))))))
    (rule $DateArg ($DateArgName $Op $DateValue) (lambda arg (lambda value (lambda op (call @paramForm (string "Date") (var arg) (var op) (var value))))))
    (rule $TimeArg ($TimeArgName $Op $TimeValue) (lambda arg (lambda op (lambda value (call @paramForm (string "Time") (var arg) (var op) (var value))))))
    (rule $BoolArg ($BoolArgName $Op $BoolValue) (lambda arg (lambda op (lambda value (call @paramForm (string "Bool") (var arg) (var op) (var value))))))
    (rule $NumArg ($NumArgName $NumOp $NumValue) (lambda arg (lambda op (lambda value (call @paramForm (string "Number") (var arg) (var op) (var value))))))
    (rule $TempArg ($TempArgName $NumOp $TempValue) (lambda arg (lambda op (lambda value (call @paramForm (string "Measure") (var arg) (var op) (var value))))))

    # Arguments
    (rule $Arg ($StringArg) (IdentityFn))
    (rule $Arg ($ArrayArg) (IdentityFn))
    (rule $Arg ($DateArg) (IdentityFn))
    (rule $Arg ($TimeArg) (IdentityFn))
    (rule $Arg ($BoolArg) (IdentityFn))
    (rule $Arg ($NumArg) (IdentityFn))
    (rule $Arg ($TempArg) (IdentityFn))
)

# Naive argument handling: Action -> Action0 | Action1 | ...
#   Action1 -> Action0 with Arg
#   Action2 -> Action1 with Arg
#   ...
# ActionName -> ... (see lexicon)
(when (or parse generate)
    (rule $ActionName ($PHRASE) (thingtalk.ThingpediaLexiconFn channel))

    (rule $Action0 ($ActionName) (lambda act (call @actParam (var act))))
    (rule $Action1 ($Action0 with $Arg) (lambda act (lambda arg (call @actParam (var act) (var arg)))))
    (rule $Action2 ($Action1 with $Arg) (lambda act (lambda arg (call @actParam (var act) (var arg)))))
    (rule $Action3 ($Action2 with $Arg) (lambda act (lambda arg (call @actParam (var act) (var arg)))))

    (rule $Action ($Action0) (IdentityFn))
    (rule $Action ($Action1) (IdentityFn))
    (rule $Action ($Action2) (IdentityFn))
    (rule $Action ($Action3) (IdentityFn))
)

# Naive argument handling: Trigger -> Trigger0 | Trigger1 | ...
#   Trigger1 -> Trigger0 and Arg
#   Trigger2 -> Trigger1 and Arg
#   ...
# TriggerName -> ... (see lexicon)
(when (or parse generate)
    (rule $TriggerName ($PHRASE) (thingtalk.ThingpediaLexiconFn channel))

    (rule $Trigger0 ($TriggerName) (lambda trig (call @trigParam (var trig))))
    (rule $Trigger1 ($Trigger0 and $Arg) (lambda trig (lambda arg (call @trigParam (var trig) (var arg)))))
    (rule $Trigger2 ($Trigger1 and $Arg) (lambda trig (lambda arg (call @trigParam (var trig) (var arg)))))
    (rule $Trigger3 ($Trigger2 and $Arg) (lambda trig (lambda arg (call @trigParam (var trig) (var arg)))))

    (rule $Trigger ($Trigger0) (IdentityFn))
    (rule $Trigger ($Trigger1) (IdentityFn))
    (rule $Trigger ($Trigger2) (IdentityFn))
    (rule $Trigger ($Trigger3) (IdentityFn))
)

# Rule -> "If" Trigger "then" Action
(when (or parse generate)
    (rule $Rule (if $Trigger then $Action) (lambda trig (lambda act (call @ifttt (var trig) (var act)))))
)

# Program -> Rule
(when (or parse generate)
    (rule $Program ($Rule) (lambda rule (call @jsonOut (var rule))))
    (rule $Program ($Action) (lambda act (call @jsonOut (var act))))
    # Chaining: Program -> Rule Rule
    # (rule $Program ($Rule $Rule) (MergeFn tt:program))
)

# Special -> "yes" | "no" | ... (see lexicon)
(when parse
    (rule $Special ($PHRASE) (SimpleLexiconFn (type tt:type.special)))
)

# Root -> Special word | Program | Parameter
(when (or parse generate)
    (rule $ROOT ($Program) (IdentityFn))
)

(when parse
    (rule $ROOT ($Special) (lambda spl (call @special (var spl))))
)

# the stuff below was borrowed from the sparql/freebase side of SEMPRE
#(when parse
#    (rule $ValueNP ($PHRASE) (IdentityFn) (anchored 1))
#    (rule $ValueNP ($PHRASE) (NumberFn) (anchored 1))
#    (rule $ValueNP ($PHRASE) (DateFn) (anchored 1))
#)

#(when generate
#(when parse
#    (rule $ValueNP (giovanni) (ConstantFn (string "giovanni")))
#
#    (rule $ValueNP (2) (ConstantFn (number 2)))
#    (rule $ValueNP (10) (ConstantFn (number 10)))
#
#    (rule $ValueNP (February 28th) (ConstantFn (date -1 2 28)))
#    (rule $ValueNP (New Year 2017) (ConstantFn (date 2017 1 1)))
#    (rule $ValueNP (the 1st) (ConstantFn (date -1 -1 1)))
#)

#(when (or parse generate)
#(when parse
#    (rule $NP (me) (ConstantFn tt:me fb:type.any))
#    (rule $NP (people) (ConstantFn (rdf:type foaf:Person) fb:type.any))
#    (rule $NP ($ValueNP) (IdentityFn))
#)

#(when (or parse generate)
#(when parse
#    (rule $RelNP (name) (ConstantFn (reverse foaf:name) (-> fb:type.any fb:type.any)))
#    (rule $NP ($RelNP of $NP) (JoinFn forward))  # name of bla => ((reverse foaf:name) bla)
#    (rule $NP ($NP whose $RelNP is $NP) (lambda x (lambda r (lambda y (and (var x) ((reverse (var r)) (var y)))))))
#)
# people whose name is bla => (and (rdf:type foaf:Person) ((reverse (reverse foaf:name)) bla))

# Generalized verbs
#(when (or parse generate)
#(when parse
#    (rule $VP/NP (be friend of) (ConstantFn foaf:knows (-> fb:type.any fb:type.any)))
#    (rule $NP ($NP that $VP/NP $NP) (lambda x (lambda r (lambda y (and (var x) ((var r) (var y)))))))  # people that were born in Seattle
#    (rule $NP ($NP that $NP $VP/NP) (lambda x (lambda y (lambda r (and (var x) ((reverse (var r)) (var y)))))))
#)
# people I am friend of         => (and (rdf:type foaf:Person) ((reverse foaf:knows) tt:me))
# (canonically: people that me be friend of)
# people who are friends of me  => (and (rdf:type foaf:Person) (foaf:knows tt:me))
# (canonically: people that be friend of me)

# Top-level
#(when (or parse generate)
#(when parse
#    (rule $Question ($NP with the largest $RelNP) (lambda x (lambda y (argmax 1 5 (var x) (var y)))))
#    (rule $Question (number of $NP) (lambda x (count (var x))))
#)

#(when parse
#    (rule $Question ($NP) (IdentityFn))
#)

#(when (or parse generate)
#(when parse
#    (rule $ROOT ($Question) (lambda x (call @toSparqlQuestion (var x))))
#)
